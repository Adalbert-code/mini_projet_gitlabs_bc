##############################################
#   VARIABLES GLOBALES
##############################################
# SSH_KEY_PS configurée en type File dans GitLab CI/CD Variables

variables:
  IMAGE_NAME: "${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}"
  DOCKER_DRIVER: overlay2
  GIT_DEPTH: "0"
  AMI_ID: "ami-0866a3c8686eaeeba"
  KEY_NAME: "bootcampgitlabci"
  SECURITY_GROUP: "sg-0bbefc4a13af1f48b"
  INSTANCE_TYPE: "t2.micro"
  STORAGE: 100
  #IMAGE_NAME: "${CI_COMMIT_REF_NAME}"  # Harmonisation de l'image utilisée partout
  DOCKER_READY_TIMEOUT: 300  # 5 minutes max pour attendre Docker

image: docker:latest
services:
  - name: docker:dind
    alias: docker

##############################################
#   STAGES
##############################################

stages:
  - lint
  - build
  - test
  - scan
  - sonarcloud
  - release
  - deploy_review
  - stop_review
  - deploy_staging
  - test_staging
  - deploy_prod
  - test_prod

##############################################
#   LINT
##############################################

linting:
  stage: lint
  image: python:3.10
  script:
    - pip install flake8
    - flake8 --ignore=E501,E303 .
    - wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
    - chmod +x /usr/local/bin/hadolint
    - hadolint --ignore DL3018 Dockerfile
  rules:
    - when: always

##############################################
#   BUILD
##############################################

docker-build:
  stage: build
  script:
    - docker build -t alpinehelloworld .
    - docker save alpinehelloworld > alpinehelloworld.tar
  artifacts:
    paths:
      - alpinehelloworld.tar
    expire_in: 1 hour
  rules:
    - when: always

##############################################
#   TEST ACCEPTATION
##############################################

test_acceptation:
  stage: test
  dependencies:
    - docker-build
  script:
    - docker load < alpinehelloworld.tar
    - docker run -d -p 80:5000 -e PORT=5000 --name webapp alpinehelloworld
    - sleep 5
    - apk add --no-cache curl
    - curl http://docker | grep "Hello world!"
  after_script:
    - docker stop webapp || true
    - docker rm webapp || true
  rules:
    - when: always

##############################################
#   SCAN SECURITE - TRIVY
##############################################

trivy-scan:
  stage: scan
  dependencies:
    - docker-build
  script:
    - docker load < alpinehelloworld.tar
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    - trivy image --severity HIGH,CRITICAL --exit-code 0 alpinehelloworld
  rules:
    - when: always
  allow_failure: true

##############################################
#   sonarcloud
##############################################

sonarcloud-check:
  stage: sonarcloud
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - |
      sonar-scanner \
        -Dsonar.projectKey=$SONAR_PROJECT_KEY \
        -Dsonar.organization=$SONAR_ORGANIZATION \
        -Dsonar.host.url=$SONAR_HOST_URL \
        -Dsonar.token=$SONAR_TOKEN \
        -Dsonar.sources=webapp \
        -Dsonar.python.version=3.10
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: always
  allow_failure: true

##############################################
#   RELEASE IMAGE
##############################################

release_image:
  stage: release
  dependencies:
    - docker-build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - docker load < alpinehelloworld.tar
    - docker tag alpinehelloworld "$IMAGE_NAME"
    - docker push "$IMAGE_NAME"
    - echo "Image pushed successfully to $IMAGE_NAME"
  after_script:
    - docker logout "$CI_REGISTRY"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always

##############################################
#   TEMPLATE - SSH DEPLOY (UPDATED)
##############################################

.deploy_ssh_template: &deploy_ssh_template
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - |
      if [ -f "$SSH_KEY_PS" ]; then
        cp "$SSH_KEY_PS" ~/.ssh/id_rsa
      else
        echo "ERROR: SSH_KEY_PS file not found. Make sure SSH_KEY_PS is defined as a File variable in GitLab CI/CD settings."
        exit 1
      fi
    - chmod 400 ~/.ssh/id_rsa
    - touch ~/.ssh/known_hosts
  script:
    - echo "Deploying to $TARGET_HOST as $SSH_USER"
    - ssh-keyscan -H "$TARGET_HOST" >> ~/.ssh/known_hosts
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${SSH_USER}@${TARGET_HOST} "echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY' && docker pull '$IMAGE_NAME' && docker stop webapp || true && docker rm webapp || true && docker run -d -p 80:5000 -e PORT=5000 --restart unless-stopped --name webapp '$IMAGE_NAME'"

##############################################
#   DEPLOY REVIEW (AWS EC2)
##############################################

deploy_review:
  stage: deploy_review
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    url: $REVIEW_ENVIRONMENT_URL
    on_stop: stop_review
  before_script:
    - apk add --no-cache python3 py3-pip openssh-client
    - python3 -m venv venv
    - source venv/bin/activate
    - pip install awscli
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_DEFAULT_REGION
  script:
    - export TAG="review-$CI_COMMIT_REF_SLUG"
    
    # Verifier si l'instance existe deja
    - |
      INSTANCE_ID=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$TAG" "Name=instance-state-name,Values=running,pending,stopping,stopped" \
        --query "Reservations[*].Instances[*].InstanceId" \
        --output text)
    
    # Si non existe, creer
    - |
      if [ -z "$INSTANCE_ID" ]; then
        echo "Creating new EC2 instance for review environment"
        USER_DATA=$(cat <<'USERDATA'
      #!/bin/bash
      curl -fsSL https://get.docker.com | sh
      sudo usermod -aG docker ubuntu
      USERDATA
        )
        
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id $AMI_ID \
          --count 1 \
          --instance-type $INSTANCE_TYPE \
          --key-name $KEY_NAME \
          --security-group-ids $SECURITY_GROUP \
          --block-device-mappings DeviceName=/dev/sda1,Ebs={VolumeSize=$STORAGE} \
          --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$TAG}]" \
          --user-data "$USER_DATA" \
          --query "Instances[0].InstanceId" \
          --output text)
        
        echo "Waiting for instance to be running..."
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID
        sleep 30
      else
        echo "Using existing instance $INSTANCE_ID"
        # S'assurer que l'instance est demarree
        STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].State.Name" --output text)
        if [ "$STATE" = "stopped" ]; then
          aws ec2 start-instances --instance-ids $INSTANCE_ID
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          sleep 20
        fi
      fi
    
    # Recuperer l'IP publique
    - |
      HOSTNAME_DEPLOY_REVIEW=$(aws ec2 describe-instances \
        --instance-ids $INSTANCE_ID \
        --query "Reservations[*].Instances[*].PublicIpAddress" \
        --output text)
      echo "Review environment IP: $HOSTNAME_DEPLOY_REVIEW"
    
    # Deployer via SSH avec SSH_KEY_PS pour Review
    - mkdir -p ~/.ssh
    - |
      if [ -f "$SSH_KEY_PS" ]; then
        cp "$SSH_KEY_PS" ~/.ssh/id_rsa
      else
        echo "ERROR: SSH_KEY_PS file not found. Make sure SSH_KEY_PS is defined as a File variable in GitLab CI/CD settings."
        exit 1
      fi
    - chmod 400 ~/.ssh/id_rsa
    - ssh-keyscan -H "$HOSTNAME_DEPLOY_REVIEW" >> ~/.ssh/known_hosts
    - echo "Deploying to Review environment $HOSTNAME_DEPLOY_REVIEW"
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${SSH_USER}@${HOSTNAME_DEPLOY_REVIEW} "echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY' && docker pull '$IMAGE_NAME' && docker stop webapp || true && docker rm webapp || true && docker run -d -p 80:5000 -e PORT=5000 --restart unless-stopped --name webapp '$IMAGE_NAME'"
    
    # Export URL
    - echo "REVIEW_ENVIRONMENT_URL=http://$HOSTNAME_DEPLOY_REVIEW" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $AWS_ACCESS_KEY_ID != null
      when: always
    - when: never

##############################################
#   STOP REVIEW (AWS)
##############################################

stop_review:
  stage: stop_review
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  when: manual
  before_script:
    - apk add --no-cache python3 py3-pip
    - python3 -m venv venv
    - source venv/bin/activate
    - pip install awscli
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_DEFAULT_REGION
  script:
    - export TAG="review-$CI_COMMIT_REF_SLUG"
    - export NEW_TAG="destroyed-$CI_COMMIT_REF_SLUG"
    
    - |
      INSTANCE_ID=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$TAG" \
        --query "Reservations[*].Instances[*].InstanceId" \
        --output text)
    
    - |
      if [ -n "$INSTANCE_ID" ]; then
        echo "Terminating instance $INSTANCE_ID"
        aws ec2 create-tags --resources $INSTANCE_ID --tags Key=Name,Value=$NEW_TAG
        aws ec2 terminate-instances --instance-ids $INSTANCE_ID
        echo "Review environment stopped"
      else
        echo "No instance found for $TAG"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $AWS_ACCESS_KEY_ID != null
      when: manual
    - when: never

##############################################
#   DEPLOY STAGING
##############################################

deploy_staging:
  stage: deploy_staging
  variables:
    TARGET_HOST: "$HOSTNAME_DEPLOY_STAGING"
  environment:
    name: staging
    url: http://$HOSTNAME_DEPLOY_STAGING
  <<: *deploy_ssh_template
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always

##############################################
#   TEST STAGING
##############################################

test_staging:
  stage: test_staging
  image: alpine:latest
  variables:
    DOMAIN: "$HOSTNAME_DEPLOY_STAGING"
  script:
    - apk add --no-cache curl
    - echo "Testing staging environment at http://$DOMAIN"
    - curl -f "http://$DOMAIN" | grep "Hello world"
    - echo "Staging tests passed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always

##############################################
#   DEPLOY PROD
##############################################

deploy_prod:
  stage: deploy_prod
  variables:
    TARGET_HOST: "$HOSTNAME_DEPLOY_PROD"
  environment:
    name: production
    url: http://$HOSTNAME_DEPLOY_PROD
  <<: *deploy_ssh_template
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
##############################################
#   TEST PROD
##############################################

test_prod:
  stage: test_prod
  image: alpine:latest
  variables:
    DOMAIN: "$HOSTNAME_DEPLOY_PROD"
  script:
    - apk add --no-cache curl
    - echo "Testing production environment at http://$DOMAIN"
    - curl -f "http://$DOMAIN" | grep "Hello world"
    - echo "Production tests passed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  needs:
    - job: deploy_prod
      optional: true
